FP
[«Страшные» абстракции Haskell без математики и без кода (почти). Часть I](https://habr.com/ru/post/272115/)
### Отличия функциональных и императивных программ
Обычно в императивном подходе, входящие данные присваиваются переменным, а затем эти переменные многократно последовательно 
изменяются, пока мы не получим нужные нам данные, которые мы и выдаём.

Суть ФП в иммутабельности данных и в композиции функций.
В ФП превращение входящих данных в исходящие происходит путем применения к ним некоторой формулы, в которой 
конечный результат выражен в терминах зависимости от входящих данных.
Зная исходные данные (путь S и время t), а также формулу(функция) (S / t) = — среднюю скорость движения
По такому же принципу зависимости конечного результата от исходных данных вычисляется и конечный результат работы программы, написанной в функциональном стиле. 
При этом, в отличие от императивного программирования, в процессе вычисления у нас не происходит никакого изменения переменных — ни локальных, ни глобальных.
Очень часто в ИП мы привыкли говорить функция(метод) - более правильно сказать процедура(которая используется, чтобы избежать повторения неоднократно встречающихся кусков кода.)

Что дает нам ФП
1. позволяет компилятору эффективно оптимизировать вычисления.
2. Отсутствие побочных эффектов и независимость работы чистых функций от внешнего состояния, позволяет программисту легко поддерживать, тестировать и рефакторить
3. Без всяких усилий писать распараллеливаемый код, не заботясь о гонке данных.

!! Чистая функция всегда должна выдавать только один результат.

### Познаём преимущества чистых функций
«чистыми» функции называют для того, чтобы их не путали с тем, что подразумевают под термином «функция» в ИП(это обычные функции в математическом понимании этого термина)
```javascript
 // addThreeNumbers x y z = x + y + z Справа от знака = указывается, каким образом вычисляется результат функции, в терминах ее аргументов.
```

**[Memoization](https://wiki.haskell.org/Memoization)**
Когда мы подаем ЧФ и вызываем её несколько раз с однаковыми аргументами  мы всегда гарантировано получим один и тот же результат.
Запоминает вычисленный однажды результат, и при повторном вызове функции с теми же аргументами не вычисляет его снова, а подставляет ранее вычисленный.

**Знак** = (равно). В отличие от ИП, он не означает операции присваивания. Знак равно означает, что то, что стоит слева от него — это то же самое, что и выражение справа от него.
Как в математике: 6 + 4 — это то же самое, что 10, поэтому мы пишем 6 + 4 = 10.
Результат ЧФ зависит только лишь от ее аргументов.
Функция в математическом смысле этого слова всегда должна возвращать результат
```javascript
// fn(6, 4); === fn((3+ 3), (3+ 1)); Сколько бы раз мы ни вызвали эту функцию с одними и теми же аргументами, она всегда вернет нам один и тот же результат, не зависит от внешнего состояния, fn но и не способна его изменять. 
```
ЧФ не обращается к какому-либо внешнему состоянию.
**Что еще нам дают ЧФ** 
Результат вычисления ЧФ не зависит от внешнего состояния и не изменяет его, мы можем вычислять такие функции параллельно,
не заботясь о гонке данных, которые конкурируют друг с другом за общие ресурсы. Побочные эффекты — погибель параллельных вычислений, 
а раз наши чистые функции их не имеют, нам не о чем беспокоиться.
Композиция функций f . g означает то же самое, что и f (g x) — т.е. функция f, применённая к результату применения функции g к аргументу x.
### Композиция
В математике для обозначения композиции функций используется запись f ∘ g, что означает «f после g».
Любая программа, написанная на ФЯ, является ничем иным, как композицией функций!
Данные перетекают из одной функции в другую, трансформируясь, и единственное условие для композиции функций — чтобы данные, 
возвращаемые одной функцией, имели тот же самый тип, который принимает следующая функция.

Какие есть проблемы в реально мире?
 - *пользовательского ввод* - ввод символа с клавиатуры,  вычисляемое значение всегда будет разным
 - **недетерминированными вычислениями** - правильный результат вычислений не один, а их много(перевод слова)б ЧФ один результат
 - ** Исключения** — это совсем не тот результат, который мы ожидаем от чистых функций!
 - **продолжениями** -  производим какие-то вычисления, а затем, не дождавшись их окончания, сохраняем текущее состояние и переключаемся на выполнение какой-то другой задачи, 
   чтобы после ее выполнения вернуться к незавершенным вычислениям и продолжить с того места, где мы остановились. ФП(нет состояния)
   
### Вычисления и «что-то ещё»
Какие проблемы нам предстоит решить, прежде чем использовать преимущества ЧФ(Исключим OI)
- Передача функции арг. для которых она не определена, хотим вернуть что-то еще исключение ошибке или null ИП
- Возврат несколько результатов(список результатов, пустой список результатов)
- Для выч. знач. функции не только арг. но и что-то еше(данные из внешнего окружения, или настройки конфига)
- Получить результат выч. и передать в след. функцию, но и применить его в кач. аргумента(получив некоторое состояние, к которому можно затем вернуться, чтобы продолжить вычисления)
- Иногда мы хотим не только произвести вычисления, но и сделать что-то ещё (например, записать что-то в лог).
- Передать следующей функции не только результат нашего вычисления, но и некоторое состояние, которое мы сначала считали откуда-то, а затем как-то контролируемо изменили.
```javascript
// функция (аргументы и/или иногда что-то ещё) 
  {
    // сделай чистые вычисления 
    //    и/или
    // сделай что-то ещё
    // return (результат чистых вычислений и/или что-то ещё) 
  }
```
!!Можно, конечно, передавать это «что-то ещё» в качестве дополнительного аргумента в наши функции (такой подход 
применяется в ИП, и называется «выделением состояния» (threading state)), но смешивать чистые вычисления с «чем-то ещё» в одну кучу — не самая лучшая идея. 
Кроме того, это не позволит нам получить единое решение для всех описанных ситуаций.
Стоит разделить на два параллельных потока
- Поток связанный с вычислениями
- Поток в котором храним или обрабатываем что-то еще а именно, контекст вычисления (потому что в ходе вычисления контекст может не только храниться, но и изменяться, если мы, например, подсчитываем, сколько шашлыков получится из овец, находящихся в стаде).
Для максимально обобщенного решения мы можем использовать дополнительный тип.
Тип функции который принимает в кач. аргумента другие типы  
  
**Инкапсуляция «чего-то ещё»**
```javascript
// data DistanceInMeters = Meter Double
// data DistanceInInches = Inch Double
``` 
DistanceInMeters и DistanceInInches называются конструкторами типов, а Meter и Inch — конструкторами данных(это функции)

Отделения чистых вычислений от «чего-то ещё» — нам нужно, чтобы наши «обёртки», выражающие это «что-то ещё», могли принимать в качестве своих аргументов любой тип. 
И эта задача тоже очень легко решается в Haskell
В наших обертках параллельно с чистыми вычислениями происходят вычисления «чего-то ещё», и результат этого вычисления мы можем передать в следующую функцию.


Maybe - поможет работать с ЧФ, которые определены не для всех своих аргументов
```javascript
// data Maybe a = Nothing | Just a Для того, чтобы узнать, есть ли какие-то данные внутри обёртки Maybe, нам нужно лишь проинспектировать обёртку.
```
Если значение нашего вычисления зависит от некоторого внешнего окружения, которое мы должны прочитать и передать в качестве аргумента функции, вычисляющей нужное нам значение
```javascript
// Окружение (Environment), от которого зависит наш результат вычислений, обозначается переменной типа e
// data Reader e a = Reader (e -> a) вычисление имеет тип e -> a, т.е. это функция из окружения в нужное нам значение.
```

**Функтор — это не просто, а очень просто!**
